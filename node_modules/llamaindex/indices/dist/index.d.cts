export * from '@llamaindex/core/indices';
import { ContextChatEngineOptions, BaseChatEngine, ContextChatEngine } from '@llamaindex/core/chat-engine';
import { BaseTool, ToolMetadata, LLM, MessageContent } from '@llamaindex/core/llms';
import { BaseQueryEngine, QueryBundle, RetrieverQueryEngine } from '@llamaindex/core/query-engine';
import { BaseSynthesizer } from '@llamaindex/core/response-synthesizers';
import { BaseRetriever } from '@llamaindex/core/retriever';
import * as _llamaindex_core_schema from '@llamaindex/core/schema';
import { Document, BaseNode, NodeWithScore, ModalityType } from '@llamaindex/core/schema';
import { BaseDocumentStore, RefDocInfo } from '@llamaindex/core/storage/doc-store';
import { BaseIndexStore } from '@llamaindex/core/storage/index-store';
import { JSONSchemaType } from 'ajv';
import { VectorStoreByType, VectorStoreQueryMode } from '@llamaindex/core/vector-store';
import { JSONValue } from '@llamaindex/core/global';
import { KeywordTable, IndexList, IndexDict } from '@llamaindex/core/data-structs';
import { BaseNodePostprocessor } from '@llamaindex/core/postprocessor';
import { KeywordExtractPrompt, QueryKeywordExtractPrompt, ChoiceSelectPrompt } from '@llamaindex/core/prompts';
import { BaseEmbedding } from '@llamaindex/core/embeddings';
import { VectorStoreByType as VectorStoreByType$1, MetadataFilters, BaseVectorStore, VectorStoreQueryResult } from '../../vector-store/dist/index.cjs';

interface StorageContext {
    docStore: BaseDocumentStore;
    indexStore: BaseIndexStore;
    vectorStores: VectorStoreByType;
}

type QueryEngineToolParams = {
    queryEngine: BaseQueryEngine;
    metadata?: ToolMetadata<JSONSchemaType<QueryEngineParam>> | undefined;
    includeSourceNodes?: boolean;
};
type QueryEngineParam = {
    query: string;
};
declare class QueryEngineTool implements BaseTool<QueryEngineParam> {
    private queryEngine;
    metadata: ToolMetadata<JSONSchemaType<QueryEngineParam>>;
    includeSourceNodes: boolean;
    constructor({ queryEngine, metadata, includeSourceNodes, }: QueryEngineToolParams);
    call({ query }: QueryEngineParam): Promise<JSONValue>;
}

interface BaseIndexInit<T> {
    storageContext: StorageContext;
    docStore: BaseDocumentStore;
    indexStore?: BaseIndexStore | undefined;
    indexStruct: T;
}
/**
 * Common parameter type for queryTool and asQueryTool
 */
type QueryToolParams = ({
    options: any;
    retriever?: never;
} | {
    options?: never;
    retriever?: BaseRetriever;
}) & {
    responseSynthesizer?: BaseSynthesizer;
    metadata?: ToolMetadata<JSONSchemaType<QueryEngineParam>> | undefined;
    includeSourceNodes?: boolean;
};
/**
 * Indexes are the data structure that we store our nodes and embeddings in so
 * they can be retrieved for our queries.
 */
declare abstract class BaseIndex<T> {
    storageContext: StorageContext;
    docStore: BaseDocumentStore;
    indexStore?: BaseIndexStore | undefined;
    indexStruct: T;
    constructor(init: BaseIndexInit<T>);
    /**
     * Create a new retriever from the index.
     * @param options
     */
    abstract asRetriever(options?: any): BaseRetriever;
    /**
     * Create a new query engine from the index. It will also create a retriever
     * and response synthezier if they are not provided.
     * @param options you can supply your own custom Retriever and ResponseSynthesizer
     */
    abstract asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
    }): BaseQueryEngine;
    /**
     * Create a new chat engine from the index.
     * @param options
     */
    abstract asChatEngine(options?: Omit<ContextChatEngineOptions, "retriever">): BaseChatEngine;
    /**
     * Returns a query tool by calling asQueryEngine.
     * Either options or retriever can be passed, but not both.
     * If options are provided, they are passed to generate a retriever.
     */
    asQueryTool(params: QueryToolParams): QueryEngineTool;
    /**
     * Insert a document into the index.
     * @param document
     */
    insert(document: Document): Promise<void>;
    abstract insertNodes(nodes: BaseNode[]): Promise<void>;
    abstract deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
    /**
     * Alias for asRetriever
     * @param options
     */
    retriever(options?: any): BaseRetriever;
    /**
     * Alias for asQueryEngine
     * @param options you can supply your own custom Retriever and ResponseSynthesizer
     */
    queryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
    }): BaseQueryEngine;
    /**
     * Alias for asQueryTool
     * Either options or retriever can be passed, but not both.
     * If options are provided, they are passed to generate a retriever.
     */
    queryTool(params: QueryToolParams): QueryEngineTool;
}

declare function expandTokensWithSubtokens(tokens: Set<string>): Set<string>;
declare function extractKeywordsGivenResponse(response: string, startToken?: string, lowercase?: boolean): Set<string>;
declare function simpleExtractKeywords(textChunk: string, maxKeywords?: number): Set<string>;
declare function rakeExtractKeywords(textChunk: string, maxKeywords?: number): Set<string>;

interface KeywordIndexOptions {
    nodes?: BaseNode[];
    indexStruct?: KeywordTable;
    indexId?: string;
    llm?: LLM;
    storageContext?: StorageContext;
}
declare enum KeywordTableRetrieverMode {
    DEFAULT = "DEFAULT",
    SIMPLE = "SIMPLE",
    RAKE = "RAKE"
}
declare abstract class BaseKeywordTableRetriever extends BaseRetriever {
    protected index: KeywordTableIndex;
    protected indexStruct: KeywordTable;
    protected docstore: BaseDocumentStore;
    protected llm: LLM;
    protected maxKeywordsPerQuery: number;
    protected numChunksPerQuery: number;
    protected keywordExtractTemplate: KeywordExtractPrompt;
    protected queryKeywordExtractTemplate: QueryKeywordExtractPrompt;
    constructor({ index, keywordExtractTemplate, queryKeywordExtractTemplate, maxKeywordsPerQuery, numChunksPerQuery, }: {
        index: KeywordTableIndex;
        keywordExtractTemplate?: KeywordExtractPrompt;
        queryKeywordExtractTemplate?: QueryKeywordExtractPrompt;
        maxKeywordsPerQuery: number;
        numChunksPerQuery: number;
    });
    abstract getKeywords(query: string): Promise<string[]>;
    _retrieve(query: QueryBundle): Promise<NodeWithScore[]>;
}
declare class KeywordTableLLMRetriever extends BaseKeywordTableRetriever {
    getKeywords(query: string): Promise<string[]>;
}
declare class KeywordTableSimpleRetriever extends BaseKeywordTableRetriever {
    getKeywords(query: string): Promise<string[]>;
}
declare class KeywordTableRAKERetriever extends BaseKeywordTableRetriever {
    getKeywords(query: string): Promise<string[]>;
}
type KeywordTableIndexChatEngineOptions = {
    retriever?: BaseRetriever;
} & Omit<ContextChatEngineOptions, "retriever">;
/**
 * The KeywordTableIndex, an index that extracts keywords from each Node and builds a mapping from each keyword to the corresponding Nodes of that keyword.
 */
declare class KeywordTableIndex extends BaseIndex<KeywordTable> {
    constructor(init: BaseIndexInit<KeywordTable>);
    static init(options: KeywordIndexOptions): Promise<KeywordTableIndex>;
    asRetriever(options?: any): BaseRetriever;
    asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
        preFilters?: unknown;
        nodePostprocessors?: BaseNodePostprocessor[];
    }): BaseQueryEngine;
    asChatEngine(options?: KeywordTableIndexChatEngineOptions): BaseChatEngine;
    static extractKeywords(text: string): Promise<Set<string>>;
    /**
     * High level API: split documents, get keywords, and build index.
     * @param documents
     * @param args
     * @param args.storageContext
     * @returns
     */
    static fromDocuments(documents: Document[], args?: {
        storageContext?: StorageContext;
    }): Promise<KeywordTableIndex>;
    /**
     * Get keywords for nodes and place them into the index.
     * @param nodes
     * @param docStore
     * @returns
     */
    static buildIndexFromNodes(nodes: BaseNode[], docStore: BaseDocumentStore): Promise<KeywordTable>;
    insertNodes(nodes: BaseNode[]): Promise<void>;
    deleteNode(nodeId: string): void;
    deleteNodes(nodeIds: string[], deleteFromDocStore: boolean): Promise<void>;
    deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
}

type NodeFormatterFunction = (summaryNodes: BaseNode[]) => string;
declare const defaultFormatNodeBatchFn: NodeFormatterFunction;
type ChoiceSelectParseResult = {
    [docNumber: number]: number;
};
type ChoiceSelectParserFunction = (answer: string, numChoices: number, raiseErr?: boolean) => ChoiceSelectParseResult;
declare const defaultParseChoiceSelectAnswerFn: ChoiceSelectParserFunction;

declare enum SummaryRetrieverMode {
    DEFAULT = "default",
    LLM = "llm"
}
type SummaryIndexChatEngineOptions = {
    retriever?: BaseRetriever;
    mode?: SummaryRetrieverMode;
} & Omit<ContextChatEngineOptions, "retriever">;
interface SummaryIndexOptions {
    nodes?: BaseNode[] | undefined;
    indexStruct?: IndexList | undefined;
    indexId?: string | undefined;
    storageContext?: StorageContext | undefined;
}
/**
 * A SummaryIndex keeps nodes in a sequential order for use with summarization.
 */
declare class SummaryIndex extends BaseIndex<IndexList> {
    constructor(init: BaseIndexInit<IndexList>);
    static init(options: SummaryIndexOptions): Promise<SummaryIndex>;
    static fromDocuments(documents: Document[], args?: {
        storageContext?: StorageContext | undefined;
    }): Promise<SummaryIndex>;
    asRetriever(options?: {
        mode: SummaryRetrieverMode;
    }): BaseRetriever;
    asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
        preFilters?: unknown;
        nodePostprocessors?: BaseNodePostprocessor[];
    }): RetrieverQueryEngine;
    asChatEngine(options?: SummaryIndexChatEngineOptions): BaseChatEngine;
    static buildIndexFromNodes(nodes: BaseNode[], docStore: BaseDocumentStore, indexStruct?: IndexList): Promise<IndexList>;
    insertNodes(nodes: BaseNode[]): Promise<void>;
    deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
    deleteNodes(nodeIds: string[], deleteFromDocStore: boolean): Promise<void>;
    getRefDocInfo(): Promise<Record<string, RefDocInfo>>;
}
type ListIndex = SummaryIndex;
type ListRetrieverMode = SummaryRetrieverMode;
/**
 * Simple retriever for SummaryIndex that returns all nodes
 */
declare class SummaryIndexRetriever extends BaseRetriever {
    index: SummaryIndex;
    constructor(index: SummaryIndex);
    _retrieve(queryBundle: QueryBundle): Promise<NodeWithScore[]>;
}
/**
 * LLM retriever for SummaryIndex which lets you select the most relevant chunks.
 */
declare class SummaryIndexLLMRetriever extends BaseRetriever {
    index: SummaryIndex;
    choiceSelectPrompt: ChoiceSelectPrompt;
    choiceBatchSize: number;
    formatNodeBatchFn: NodeFormatterFunction;
    parseChoiceSelectAnswerFn: ChoiceSelectParserFunction;
    constructor(index: SummaryIndex, choiceSelectPrompt?: ChoiceSelectPrompt, choiceBatchSize?: number, formatNodeBatchFn?: NodeFormatterFunction, parseChoiceSelectAnswerFn?: ChoiceSelectParserFunction);
    _retrieve(query: QueryBundle): Promise<NodeWithScore[]>;
}
type ListIndexRetriever = SummaryIndexRetriever;
type ListIndexLLMRetriever = SummaryIndexLLMRetriever;

/**
 * Document de-deduplication strategies work by comparing the hashes or ids stored in the document store.
 * They require a document store to be set which must be persisted across pipeline runs.
 */
declare enum DocStoreStrategy {
    UPSERTS = "upserts",
    DUPLICATES_ONLY = "duplicates_only",
    UPSERTS_AND_DELETE = "upserts_and_delete",
    NONE = "none"
}

interface IndexStructOptions {
    indexStruct?: IndexDict | undefined;
    indexId?: string | undefined;
}
interface VectorIndexOptions extends IndexStructOptions {
    nodes?: BaseNode[] | undefined;
    storageContext?: StorageContext | undefined;
    vectorStores?: VectorStoreByType$1 | undefined;
    logProgress?: boolean | undefined;
}
interface VectorIndexConstructorProps extends BaseIndexInit<IndexDict> {
    indexStore: BaseIndexStore;
    vectorStores?: VectorStoreByType$1 | undefined;
}
type VectorIndexChatEngineOptions = {
    retriever?: BaseRetriever;
    similarityTopK?: number;
    preFilters?: MetadataFilters;
    customParams?: unknown;
} & Omit<ContextChatEngineOptions, "retriever">;
/**
 * The VectorStoreIndex, an index that stores the nodes only according to their vector embeddings.
 */
declare class VectorStoreIndex extends BaseIndex<IndexDict> {
    indexStore: BaseIndexStore;
    embedModel?: BaseEmbedding | undefined;
    vectorStores: VectorStoreByType$1;
    private constructor();
    /**
     * The async init function creates a new VectorStoreIndex.
     * @param options
     * @returns
     */
    static init(options: VectorIndexOptions): Promise<VectorStoreIndex>;
    private static setupIndexStructFromStorage;
    /**
     * Calculates the embeddings for the given nodes.
     *
     * @param nodes - An array of BaseNode objects representing the nodes for which embeddings are to be calculated.
     * @param {Object} [options] - An optional object containing additional parameters.
     *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
     */
    getNodeEmbeddingResults(nodes: BaseNode[], options?: {
        logProgress?: boolean | undefined;
    }): Promise<BaseNode[]>;
    /**
     * Get embeddings for nodes and place them into the index.
     * @param nodes
     * @returns
     */
    buildIndexFromNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean | undefined;
    }): Promise<void>;
    /**
     * High level API: split documents, get embeddings, and build index.
     * @param documents
     * @param args
     * @returns
     */
    static fromDocuments(documents: Document[], args?: VectorIndexOptions & {
        docStoreStrategy?: DocStoreStrategy;
    }): Promise<VectorStoreIndex>;
    static fromVectorStores(vectorStores: VectorStoreByType$1): Promise<VectorStoreIndex>;
    static fromVectorStore(vectorStore: BaseVectorStore): Promise<VectorStoreIndex>;
    asRetriever(options?: OmitIndex<VectorIndexRetrieverOptions>): VectorIndexRetriever;
    /**
     * Create a RetrieverQueryEngine.
     * similarityTopK is only used if no existing retriever is provided.
     */
    asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
        preFilters?: MetadataFilters;
        customParams?: unknown;
        nodePostprocessors?: BaseNodePostprocessor[];
        similarityTopK?: number;
    }): RetrieverQueryEngine;
    /**
     * Convert the index to a chat engine.
     * @param options The options for creating the chat engine
     * @returns A ContextChatEngine that uses the index's retriever to get context for each query
     */
    asChatEngine(options?: VectorIndexChatEngineOptions): ContextChatEngine;
    protected insertNodesToStore(newIds: string[], nodes: BaseNode[], vectorStore: BaseVectorStore): Promise<void>;
    insertNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean | undefined;
    }): Promise<void>;
    deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
    protected deleteRefDocFromStore(vectorStore: BaseVectorStore, refDocId: string): Promise<void>;
}
/**
 * VectorIndexRetriever retrieves nodes from a VectorIndex.
 */
type TopKMap = {
    [P in ModalityType]: number;
};
type OmitIndex<T> = T extends {
    index: any;
} ? Omit<T, "index"> : never;
type VectorIndexRetrieverOptions = {
    index: VectorStoreIndex;
    filters?: MetadataFilters | undefined;
    mode?: VectorStoreQueryMode;
    customParams?: unknown | undefined;
} & ({
    topK?: TopKMap | undefined;
} | {
    similarityTopK?: number | undefined;
});
declare class VectorIndexRetriever extends BaseRetriever {
    index: VectorStoreIndex;
    topK: TopKMap;
    filters?: MetadataFilters | undefined;
    queryMode?: VectorStoreQueryMode | undefined;
    customParams?: unknown | undefined;
    constructor(options: VectorIndexRetrieverOptions);
    /**
     * @deprecated, pass similarityTopK or topK in constructor instead or directly modify topK
     */
    set similarityTopK(similarityTopK: number);
    _retrieve(params: QueryBundle): Promise<NodeWithScore[]>;
    protected retrieveQuery(query: MessageContent, type: ModalityType, vectorStore: BaseVectorStore, filters?: MetadataFilters, customParams?: unknown): Promise<NodeWithScore[]>;
    protected buildNodeListFromQueryResult(result: VectorStoreQueryResult): NodeWithScore<_llamaindex_core_schema.Metadata>[];
}

export { BaseIndex, type BaseIndexInit, type ChoiceSelectParseResult, type ChoiceSelectParserFunction, type KeywordIndexOptions, KeywordTableIndex, type KeywordTableIndexChatEngineOptions, KeywordTableLLMRetriever, KeywordTableRAKERetriever, KeywordTableRetrieverMode, KeywordTableSimpleRetriever, type ListIndex, type ListIndexLLMRetriever, type ListIndexRetriever, type ListRetrieverMode, type NodeFormatterFunction, type QueryToolParams, SummaryIndex, type SummaryIndexChatEngineOptions, SummaryIndexLLMRetriever, type SummaryIndexOptions, SummaryIndexRetriever, SummaryRetrieverMode, type VectorIndexChatEngineOptions, type VectorIndexConstructorProps, type VectorIndexOptions, VectorIndexRetriever, type VectorIndexRetrieverOptions, VectorStoreIndex, defaultFormatNodeBatchFn, defaultParseChoiceSelectAnswerFn, expandTokensWithSubtokens, extractKeywordsGivenResponse, rakeExtractKeywords, simpleExtractKeywords };
