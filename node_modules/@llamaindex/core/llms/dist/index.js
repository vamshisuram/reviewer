import { streamConverter, extractText } from '../../utils/dist/index.js';

class BaseLLM {
    async complete(params) {
        const { prompt, stream, responseFormat } = params;
        if (stream) {
            const stream = await this.chat({
                messages: [
                    {
                        content: prompt,
                        role: "user"
                    }
                ],
                stream: true,
                ...responseFormat ? {
                    responseFormat
                } : {}
            });
            return streamConverter(stream, (chunk)=>{
                return {
                    raw: null,
                    text: chunk.delta
                };
            });
        }
        const chatResponse = await this.chat({
            messages: [
                {
                    content: prompt,
                    role: "user"
                }
            ],
            ...responseFormat ? {
                responseFormat
            } : {}
        });
        return {
            text: extractText(chatResponse.message.content),
            raw: chatResponse.raw
        };
    }
}
class ToolCallLLM extends BaseLLM {
}

const liveEvents = {
    open: {
        include: (e)=>e.type === "open"
    },
    audio: {
        include: (e)=>e.type === "audio"
    },
    text: {
        include: (e)=>e.type === "text"
    },
    error: {
        include: (e)=>e.type === "error"
    },
    close: {
        include: (e)=>e.type === "close"
    },
    setupComplete: {
        include: (e)=>e.type === "setupComplete"
    }
};
class LiveLLMSession {
    async *streamEvents() {
        while(true){
            const event = await this.nextEvent();
            if (event === undefined) {
                break;
            }
            yield event;
        }
    }
    async nextEvent() {
        if (this.eventQueue.length) {
            return Promise.resolve(this.eventQueue.shift());
        }
        return new Promise((resolve)=>{
            this.eventResolvers.push(resolve);
        });
    }
    //Uses an async queue to send events to the client
    // if the consumer is waiting for an event, it will be resolved immediately
    // otherwise, the event will be queued up and sent when the consumer is ready
    pushEventToQueue(event) {
        if (this.eventResolvers.length) {
            //resolving the promise with the event
            this.eventResolvers.shift()(event);
        } else {
            this.eventQueue.push(event);
        }
    }
    constructor(){
        this.eventQueue = [];
        this.eventResolvers = [];
        this.closed = false;
    }
}
class LiveLLM {
}

function addContentPart(message, part) {
    if (part.type === "text") {
        if (typeof message.content === "string") {
            message.content += part.text;
        } else {
            message.content.push(part);
        }
    } else {
        if (typeof message.content === "string") {
            if (message.content === "") {
                message.content = [
                    part
                ];
            } else {
                message.content = [
                    {
                        type: "text",
                        text: message.content
                    },
                    part
                ];
            }
        } else {
            message.content.push(part);
        }
    }
}

export { BaseLLM, LiveLLM, LiveLLMSession, ToolCallLLM, addContentPart, liveEvents };
