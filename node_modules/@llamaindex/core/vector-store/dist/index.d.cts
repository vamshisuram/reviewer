import { BaseEmbedding } from '../../embeddings/dist/index.cjs';
import { BaseNode, Metadata, ModalityType } from '../../schema/dist/index.cjs';

declare function validateIsFlat(obj: Record<string, unknown>): void;
declare function nodeToMetadata(node: BaseNode, removeText?: boolean, textField?: string, flatMetadata?: boolean): Metadata;
type MetadataDictToNodeOptions = {
    fallback: Record<string, unknown>;
};
declare function metadataDictToNode(metadata: Metadata, options?: MetadataDictToNodeOptions): BaseNode;
declare const escapeLikeString: (value: string) => string;

/**
 * should compatible with npm:pg and npm:postgres
 */
interface IsomorphicDB {
    query: (sql: string, params?: any[]) => Promise<any[]>;
    begin: <T>(fn: (query: IsomorphicDB["query"]) => Promise<T>) => Promise<T>;
    connect: () => Promise<void>;
    close: () => Promise<void>;
    onCloseEvent: (listener: () => void) => void;
}
interface VectorStoreQueryResult {
    nodes?: BaseNode[];
    similarities: number[];
    ids: string[];
}
declare enum VectorStoreQueryMode {
    DEFAULT = "default",
    SPARSE = "sparse",
    HYBRID = "hybrid",
    SVM = "svm",
    LOGISTIC_REGRESSION = "logistic_regression",
    LINEAR_REGRESSION = "linear_regression",
    MMR = "mmr",
    SEMANTIC_HYBRID = "semantic_hybrid"
}
declare enum FilterOperator {
    EQ = "==",// default operator (string, number)
    IN = "in",// In array (string or number)
    GT = ">",// greater than (number)
    LT = "<",// less than (number)
    NE = "!=",// not equal to (string, number)
    GTE = ">=",// greater than or equal to (number)
    LTE = "<=",// less than or equal to (number)
    NIN = "nin",// Not in array (string or number)
    ANY = "any",// Contains any (array of strings)
    ALL = "all",// Contains all (array of strings)
    TEXT_MATCH = "text_match",// full text match (allows you to search for a specific substring, token or phrase within the text field)
    CONTAINS = "contains",// metadata array contains value (string or number)
    IS_EMPTY = "is_empty"
}
declare enum FilterCondition {
    AND = "and",
    OR = "or"
}
type MetadataFilterValue = string | number | string[] | number[];
interface MetadataFilter {
    key: string;
    value?: MetadataFilterValue;
    operator: `${FilterOperator}`;
}
interface MetadataFilters {
    filters: Array<MetadataFilter>;
    condition?: `${FilterCondition}`;
}
interface MetadataInfo {
    name: string;
    type: string;
    description: string;
}
interface VectorStoreInfo {
    metadataInfo: MetadataInfo[];
    contentInfo: string;
}
interface VectorStoreQuery<T = unknown> {
    queryEmbedding?: number[];
    similarityTopK: number;
    docIds?: string[];
    queryStr?: string;
    mode: VectorStoreQueryMode;
    alpha?: number;
    filters?: MetadataFilters | undefined;
    mmrThreshold?: number;
    customParams?: T | undefined;
}
type VectorStoreByType = {
    [P in ModalityType]?: BaseVectorStore;
};
type VectorStoreBaseParams = {
    embeddingModel?: BaseEmbedding | undefined;
};
declare abstract class BaseVectorStore<Client = unknown, T = unknown> {
    embedModel: BaseEmbedding;
    abstract storesText: boolean;
    isEmbeddingQuery?: boolean;
    abstract client(): Client;
    abstract add(embeddingResults: BaseNode[]): Promise<string[]>;
    abstract delete(refDocId: string, deleteOptions?: object): Promise<void>;
    abstract query(query: VectorStoreQuery<T>, options?: object): Promise<VectorStoreQueryResult>;
    protected constructor(params?: VectorStoreBaseParams);
}
declare const parsePrimitiveValue: (value?: MetadataFilterValue) => string | number;
declare const parseArrayValue: (value?: MetadataFilterValue) => string[] | number[];
declare const parseNumberValue: (value?: MetadataFilterValue) => number;

export { BaseVectorStore, FilterCondition, FilterOperator, type IsomorphicDB, type MetadataFilter, type MetadataFilterValue, type MetadataFilters, type MetadataInfo, type VectorStoreBaseParams, type VectorStoreByType, type VectorStoreInfo, type VectorStoreQuery, VectorStoreQueryMode, type VectorStoreQueryResult, escapeLikeString, metadataDictToNode, nodeToMetadata, parseArrayValue, parseNumberValue, parsePrimitiveValue, validateIsFlat };
