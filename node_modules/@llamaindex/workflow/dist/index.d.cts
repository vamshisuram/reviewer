import * as _llama_flow_core from '@llama-flow/core';
import { WorkflowContext, WorkflowEvent, Workflow, Handler, WorkflowEventData } from '@llama-flow/core';
export * from '@llama-flow/core';
export * from '@llama-flow/core/middleware/state';
export * from '@llama-flow/core/stream/run';
import * as _llamaindex_core_tools from '@llamaindex/core/tools';
import * as _llamaindex_core_global from '@llamaindex/core/global';
import { JSONValue } from '@llamaindex/core/global';
import { ToolResult, ChatMessage, BaseToolWithCall, LLM, ToolCallLLM, MessageContent } from '@llamaindex/core/llms';
import { BaseMemory } from '@llamaindex/core/memory';

type AgentToolCall = {
    agentName: string;
    toolName: string;
    toolKwargs: Record<string, JSONValue>;
    toolId: string;
};
declare const agentToolCallEvent: _llama_flow_core.WorkflowEvent<AgentToolCall, string>;
type AgentToolCallResult = {
    toolName: string;
    toolKwargs: Record<string, JSONValue>;
    toolId: string;
    toolOutput: ToolResult;
    returnDirect: boolean;
    raw: JSONValue;
};
declare const agentToolCallResultEvent: _llama_flow_core.WorkflowEvent<AgentToolCallResult, string>;
type AgentInput = {
    input: ChatMessage[];
    currentAgentName: string;
};
declare const agentInputEvent: _llama_flow_core.WorkflowEvent<AgentInput, string>;
type AgentSetup = {
    input: ChatMessage[];
    currentAgentName: string;
};
declare const agentSetupEvent: _llama_flow_core.WorkflowEvent<AgentSetup, string>;
declare const agentStreamEvent: _llama_flow_core.WorkflowEvent<{
    delta: string;
    response: string;
    currentAgentName: string;
    raw: unknown;
}, string>;
type AgentOutput = {
    response: ChatMessage;
    toolCalls: AgentToolCall[];
    raw: unknown;
    currentAgentName: string;
};
declare const agentOutputEvent: _llama_flow_core.WorkflowEvent<AgentOutput, string>;

type AgentWorkflowState = {
    memory: BaseMemory;
    scratchpad: ChatMessage[];
    agents: string[];
    currentAgentName: string;
    nextAgentName?: string | null;
};
/**
 * Base interface for workflow agents
 */
interface BaseWorkflowAgent {
    readonly name: string;
    readonly systemPrompt: string;
    readonly description: string;
    readonly tools: BaseToolWithCall[];
    readonly llm: LLM;
    readonly canHandoffTo: string[];
    /**
     * Take a single step with the agent
     * Using memory directly to get messages instead of requiring them to be passed in
     */
    takeStep(ctx: WorkflowContext, state: AgentWorkflowState, llmInput: ChatMessage[], tools: BaseToolWithCall[]): Promise<AgentOutput>;
    /**
     * Handle results from tool calls
     */
    handleToolCallResults(state: AgentWorkflowState, results: AgentToolCallResult[]): Promise<void>;
    /**
     * Finalize the agent's output
     */
    finalize(state: AgentWorkflowState, output: AgentOutput): Promise<AgentOutput>;
}

type FunctionAgentParams = {
    /**
     * Agent name
     */
    name?: string | undefined;
    /**
     * LLM to use for the agent, required.
     */
    llm?: ToolCallLLM | undefined;
    /**
     * Description of the agent, useful for task assignment.
     * Should provide the capabilities or responsibilities of the agent.
     */
    description?: string | undefined;
    /**
     * List of tools that the agent can use, requires at least one tool.
     */
    tools: BaseToolWithCall[];
    /**
     * List of agents that this agent can delegate tasks to
     * Can be a list of agent names as strings, BaseWorkflowAgent instances, or AgentWorkflow instances
     */
    canHandoffTo?: string[] | BaseWorkflowAgent[] | AgentWorkflow[] | undefined;
    /**
     * Custom system prompt for the agent
     */
    systemPrompt?: string | undefined;
};
declare class FunctionAgent implements BaseWorkflowAgent {
    readonly name: string;
    readonly systemPrompt: string;
    readonly description: string;
    readonly llm: ToolCallLLM;
    readonly tools: BaseToolWithCall[];
    readonly canHandoffTo: string[];
    constructor({ name, llm, description, tools, canHandoffTo, systemPrompt, }: FunctionAgentParams);
    takeStep(ctx: WorkflowContext, state: AgentWorkflowState, llmInput: ChatMessage[], tools: BaseToolWithCall[]): Promise<AgentOutput>;
    handleToolCallResults(state: AgentWorkflowState, results: AgentToolCallResult[]): Promise<void>;
    finalize(state: AgentWorkflowState, output: AgentOutput): Promise<AgentOutput>;
    private getToolCallFromResponseChunk;
}

type AgentInputData = {
    userInput?: MessageContent | undefined;
    chatHistory?: ChatMessage[] | undefined;
};
declare const startAgentEvent: WorkflowEvent<AgentInputData, "llamaindex-start">;
type AgentResultData = {
    result: MessageContent;
    state?: AgentWorkflowState | undefined;
};
declare const stopAgentEvent: WorkflowEvent<AgentResultData, "llamaindex-stop">;
type ToolCalls = {
    agentName: string;
    toolCalls: AgentToolCall[];
};
declare const toolCallsEvent: WorkflowEvent<ToolCalls, string>;
type ToolResults = {
    agentName: string;
    results: AgentToolCallResult[];
};
declare const toolResultsEvent: WorkflowEvent<ToolResults, string>;
type AgentStep = {
    agentName: string;
    response: ChatMessage;
    toolCalls: AgentToolCall[];
};
declare const agentStepEvent: WorkflowEvent<AgentStep, string>;
type SingleAgentParams = FunctionAgentParams & {
    /**
     * Whether to log verbose output
     */
    verbose?: boolean;
    /**
     * Timeout for the workflow in seconds
     */
    timeout?: number;
};
type AgentWorkflowParams = {
    /**
     * List of agents to include in the workflow.
     * Need at least one agent.
     * Can also be an array of AgentWorkflow objects, in which case the agents from each workflow will be extracted.
     */
    agents: BaseWorkflowAgent[] | AgentWorkflow[];
    /**
     * The agent to start the workflow with.
     * Must be an agent in the `agents` list.
     * Can also be an AgentWorkflow object, in which case the workflow must have exactly one agent.
     */
    rootAgent: BaseWorkflowAgent | AgentWorkflow;
    verbose?: boolean;
    /**
     * Timeout for the workflow in seconds.
     */
    timeout?: number;
};
/**
 * Create a multi-agent workflow
 * @param params - Parameters for the AgentWorkflow
 * @returns A new AgentWorkflow instance
 */
declare const multiAgent: (params: AgentWorkflowParams) => AgentWorkflow;
/**
 * Create a simple workflow with a single agent and specified tools
 * @param params - Parameters for the single agent workflow
 * @returns A new AgentWorkflow instance
 */
declare const agent: (params: SingleAgentParams) => AgentWorkflow;
/**
 * AgentWorkflow - An event-driven workflow for executing agents with tools
 *
 * This class provides a simple interface for creating and running agent workflows
 * based on the LlamaIndexTS workflow system. It supports single agent workflows
 * with multiple tools.
 */
declare class AgentWorkflow implements Workflow {
    private stateful;
    private workflow;
    private agents;
    private verbose;
    private rootAgentName;
    constructor({ agents, rootAgent, verbose }: AgentWorkflowParams);
    handle<const AcceptEvents extends WorkflowEvent<unknown>[], Result extends ReturnType<WorkflowEvent<unknown>["with"]> | void>(accept: AcceptEvents, handler: Handler<AcceptEvents, Result>): void;
    createContext(): WorkflowContext;
    private addAgents;
    private validateAgent;
    private addHandoffTool;
    /**
     * Adds a new agent to the workflow
     */
    addAgent(agent: BaseWorkflowAgent): this;
    /**
     * Gets all agents in this workflow
     * @returns Array of agents in this workflow
     */
    getAgents(): BaseWorkflowAgent[];
    /**
     * Create a simple workflow with a single agent and specified tools
     * @param params - Parameters for the single agent workflow
     * @returns A new AgentWorkflow instance
     */
    static fromTools(params: SingleAgentParams): AgentWorkflow;
    private handleInputStep;
    private setupAgent;
    private runAgentStep;
    private parseAgentOutput;
    private executeToolCalls;
    private processToolResults;
    private setupWorkflowSteps;
    private callTool;
    private createInitialState;
    runStream(userInput: MessageContent, params?: {
        chatHistory?: ChatMessage[];
        state?: AgentWorkflowState;
    }): _llama_flow_core.WorkflowStream<WorkflowEventData<any, string>>;
    run(userInput: MessageContent, params?: {
        chatHistory?: ChatMessage[];
        state?: AgentWorkflowState;
    }): Promise<WorkflowEventData<AgentResultData>>;
    createHandoffTool(agents: Map<string, BaseWorkflowAgent>): _llamaindex_core_tools.FunctionTool<{
        toAgent: string;
        reason: string;
    }, _llamaindex_core_global.JSONValue | Promise<_llamaindex_core_global.JSONValue>, () => AgentWorkflowState>;
}

export { type AgentInput, type AgentInputData, type AgentOutput, type AgentResultData, type AgentSetup, type AgentStep, type AgentToolCall, type AgentToolCallResult, AgentWorkflow, type AgentWorkflowParams, type AgentWorkflowState, type BaseWorkflowAgent, FunctionAgent, type FunctionAgentParams, type SingleAgentParams, type ToolCalls, type ToolResults, agent, agentInputEvent, agentOutputEvent, agentSetupEvent, agentStepEvent, agentStreamEvent, agentToolCallEvent, agentToolCallResultEvent, multiAgent, startAgentEvent, stopAgentEvent, toolCallsEvent, toolResultsEvent };
