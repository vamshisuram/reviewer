import { workflowEvent, createWorkflow, getContext } from '@llama-flow/core';
export * from '@llama-flow/core';
import { createStatefulMiddleware } from '@llama-flow/core/middleware/state';
export * from '@llama-flow/core/middleware/state';
export * from '@llama-flow/core/stream/run';
import { Settings } from '@llamaindex/core/global';
import { ChatMemoryBuffer } from '@llamaindex/core/memory';
import { PromptTemplate } from '@llamaindex/core/prompts';
import { tool } from '@llamaindex/core/tools';
import { stringifyJSONToMessageContent } from '@llamaindex/core/utils';
import { z } from 'zod';

const agentToolCallEvent = workflowEvent();
const agentToolCallResultEvent = workflowEvent();
const agentInputEvent = workflowEvent();
const agentSetupEvent = workflowEvent();
const agentStreamEvent = workflowEvent();
const agentOutputEvent = workflowEvent();

const DEFAULT_SYSTEM_PROMPT = "You are a helpful assistant. Use the provided tools to answer questions.";
class FunctionAgent {
    constructor({ name, llm, description, tools, canHandoffTo, systemPrompt }){
        this.name = name ?? "Agent";
        this.llm = llm ?? Settings.llm;
        if (!this.llm.supportToolCall) {
            throw new Error("FunctionAgent requires an LLM that supports tool calls");
        }
        this.description = description ?? "A single agent that uses the provided tools or functions.";
        this.tools = tools;
        if (tools.length === 0) {
            throw new Error("FunctionAgent must have at least one tool");
        }
        // Process canHandoffTo to extract agent names
        this.canHandoffTo = [];
        if (canHandoffTo) {
            if (Array.isArray(canHandoffTo)) {
                if (canHandoffTo.length > 0) {
                    if (typeof canHandoffTo[0] === "string") {
                        // string[] case
                        this.canHandoffTo = canHandoffTo;
                    } else if (canHandoffTo[0] instanceof AgentWorkflow) {
                        // AgentWorkflow[] case
                        const workflows = canHandoffTo;
                        workflows.forEach((workflow)=>{
                            const agentNames = workflow.getAgents().map((agent)=>agent.name);
                            this.canHandoffTo.push(...agentNames);
                        });
                    } else {
                        // BaseWorkflowAgent[] case
                        const agents = canHandoffTo;
                        this.canHandoffTo = agents.map((agent)=>agent.name);
                    }
                }
            }
        }
        const uniqueHandoffAgents = new Set(this.canHandoffTo);
        if (uniqueHandoffAgents.size !== this.canHandoffTo.length) {
            throw new Error("Duplicate handoff agents");
        }
        this.systemPrompt = systemPrompt ?? DEFAULT_SYSTEM_PROMPT;
    }
    async takeStep(ctx, state, llmInput, tools) {
        // Get scratchpad from context or initialize if not present
        const scratchpad = state.scratchpad;
        const currentLLMInput = [
            ...llmInput,
            ...scratchpad
        ];
        const responseStream = await this.llm.chat({
            messages: currentLLMInput,
            tools,
            stream: true
        });
        let response = "";
        let lastChunk;
        const toolCalls = new Map();
        for await (const chunk of responseStream){
            response += chunk.delta;
            ctx.sendEvent(agentStreamEvent.with({
                delta: chunk.delta,
                response: response,
                currentAgentName: this.name,
                raw: chunk.raw
            }));
            const toolCallsInChunk = this.getToolCallFromResponseChunk(chunk);
            if (toolCallsInChunk.length > 0) {
                // Just upsert the tool calls with the latest one if they exist
                toolCallsInChunk.forEach((toolCall)=>{
                    toolCalls.set(toolCall.toolId, toolCall);
                });
            }
        }
        const message = {
            role: "assistant",
            content: response
        };
        if (toolCalls.size > 0) {
            message.options = {
                toolCall: Array.from(toolCalls.values()).map((toolCall)=>({
                        name: toolCall.toolName,
                        input: toolCall.toolKwargs,
                        id: toolCall.toolId
                    }))
            };
        }
        scratchpad.push(message);
        state.scratchpad = scratchpad;
        return {
            response: message,
            toolCalls: Array.from(toolCalls.values()),
            raw: lastChunk?.raw,
            currentAgentName: this.name
        };
    }
    async handleToolCallResults(state, results) {
        const scratchpad = state.scratchpad;
        for (const result of results){
            const content = result.toolOutput.result;
            const rawToolMessage = {
                role: "user",
                content,
                options: {
                    toolResult: {
                        id: result.toolId,
                        result: content,
                        isError: result.toolOutput.isError
                    }
                }
            };
            state.scratchpad.push(rawToolMessage);
        }
        state.scratchpad = scratchpad;
    }
    async finalize(state, output) {
        // Get scratchpad messages
        const scratchpad = state.scratchpad;
        for (const msg of scratchpad){
            state.memory.put(msg);
        }
        // Clear scratchpad after finalization
        state.scratchpad = [];
        return output;
    }
    getToolCallFromResponseChunk(responseChunk) {
        const toolCalls = [];
        const options = responseChunk.options ?? {};
        if (options && "toolCall" in options && Array.isArray(options.toolCall)) {
            toolCalls.push(...options.toolCall.map((call)=>{
                // Convert input to arguments format
                let toolKwargs;
                if (typeof call.input === "string") {
                    try {
                        toolKwargs = JSON.parse(call.input);
                    } catch (e) {
                        toolKwargs = {
                            rawInput: call.input
                        };
                    }
                } else {
                    toolKwargs = call.input;
                }
                return {
                    agentName: this.name,
                    toolName: call.name,
                    toolKwargs: toolKwargs,
                    toolId: call.id
                };
            }));
        }
        const invalidToolCalls = toolCalls.filter((call)=>!this.tools.some((tool)=>tool.metadata.name === call.toolName));
        if (invalidToolCalls.length > 0) {
            const invalidToolNames = invalidToolCalls.map((call)=>call.toolName).join(", ");
            throw new Error(`Tools not found: ${invalidToolNames}`);
        }
        return toolCalls;
    }
}

const DEFAULT_HANDOFF_PROMPT = new PromptTemplate({
    template: `Useful for handing off to another agent.
If you are currently not equipped to handle the user's request, or another agent is better suited to handle the request, please hand off to the appropriate agent.

Currently available agents: 
{agent_info}
`
});
const DEFAULT_HANDOFF_OUTPUT_PROMPT = new PromptTemplate({
    template: `Agent {to_agent} is now handling the request due to the following reason: {reason}.\nPlease continue with the current request.`
});
const startAgentEvent = workflowEvent({
    debugLabel: "llamaindex-start"
});
const stopAgentEvent = workflowEvent({
    debugLabel: "llamaindex-stop"
});
const toolCallsEvent = workflowEvent();
const toolResultsEvent = workflowEvent();
const agentStepEvent = workflowEvent();
/**
 * Create a multi-agent workflow
 * @param params - Parameters for the AgentWorkflow
 * @returns A new AgentWorkflow instance
 */ const multiAgent = (params)=>{
    return new AgentWorkflow(params);
};
/**
 * Create a simple workflow with a single agent and specified tools
 * @param params - Parameters for the single agent workflow
 * @returns A new AgentWorkflow instance
 */ const agent = (params)=>{
    return AgentWorkflow.fromTools(params);
};
/**
 * AgentWorkflow - An event-driven workflow for executing agents with tools
 *
 * This class provides a simple interface for creating and running agent workflows
 * based on the LlamaIndexTS workflow system. It supports single agent workflows
 * with multiple tools.
 */ class AgentWorkflow {
    constructor({ agents, rootAgent, verbose }){
        this.stateful = createStatefulMiddleware((state)=>state);
        this.workflow = this.stateful.withState(createWorkflow());
        this.agents = new Map();
        this.handleInputStep = async (event)=>{
            const { state } = this.stateful.getContext();
            const { userInput, chatHistory } = event.data;
            const memory = state.memory;
            if (chatHistory) {
                chatHistory.forEach((message)=>{
                    memory.put(message);
                });
            }
            if (userInput) {
                const userMessage = {
                    role: "user",
                    content: userInput
                };
                memory.put(userMessage);
            } else if (chatHistory) {
                // If no user message, use the last message from chat history as user_msg_str
                const lastMessage = chatHistory[chatHistory.length - 1];
                if (lastMessage?.role !== "user") {
                    throw new Error("Either provide a user message or a chat history with a user message as the last message");
                }
            } else {
                throw new Error("No user message or chat history provided");
            }
            return agentInputEvent.with({
                input: await memory.getMessages(),
                currentAgentName: this.rootAgentName
            });
        };
        this.setupAgent = async (event)=>{
            const currentAgentName = event.data.currentAgentName;
            const agent = this.agents.get(currentAgentName);
            if (!agent) {
                throw new Error(`Agent ${currentAgentName} not found`);
            }
            const llmInput = event.data.input;
            if (agent.systemPrompt) {
                llmInput.unshift({
                    role: "system",
                    content: agent.systemPrompt
                });
            }
            return agentSetupEvent.with({
                input: llmInput,
                currentAgentName: currentAgentName
            });
        };
        this.runAgentStep = async (event)=>{
            const { sendEvent } = this.stateful.getContext();
            const agent = this.agents.get(event.data.currentAgentName);
            if (!agent) {
                throw new Error("No valid agent found");
            }
            if (this.verbose) {
                console.log(`[Agent ${agent.name}]: Running for input: ${event.data.input[event.data.input.length - 1]?.content}`);
            }
            const output = await agent.takeStep(this.stateful.getContext(), this.stateful.getContext().state, event.data.input, agent.tools);
            sendEvent(agentStepEvent.with({
                agentName: agent.name,
                response: output.response,
                toolCalls: output.toolCalls
            }));
            sendEvent(agentOutputEvent.with(output));
        };
        this.parseAgentOutput = async (event)=>{
            const { agentName, response, toolCalls } = event.data;
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`parseAgentOutput failed: agent ${agentName} does not exist`);
            }
            // If no tool calls, return final response
            if (!toolCalls || toolCalls.length === 0) {
                if (this.verbose) {
                    console.log(`[Agent ${agentName}]: No tool calls to process, returning final response`);
                }
                const agentOutput = {
                    response,
                    toolCalls: [],
                    raw: response,
                    currentAgentName: agentName
                };
                const content = await agent.finalize(this.stateful.getContext().state, agentOutput);
                return stopAgentEvent.with({
                    result: content.response.content,
                    state: this.stateful.getContext().state
                });
            }
            return toolCallsEvent.with({
                agentName,
                toolCalls
            });
        };
        this.executeToolCalls = async (event)=>{
            const { sendEvent } = getContext();
            const { agentName, toolCalls } = event.data;
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            const results = [];
            // Execute each tool call
            for (const toolCall of toolCalls){
                // Send single tool call event, useful for UI
                sendEvent(agentToolCallEvent.with(toolCall));
                const toolResult = {
                    toolName: toolCall.toolName,
                    toolKwargs: toolCall.toolKwargs,
                    toolId: toolCall.toolId,
                    toolOutput: {
                        id: toolCall.toolId,
                        result: "",
                        isError: false
                    },
                    returnDirect: false,
                    raw: {}
                };
                try {
                    const output = await this.callTool(toolCall);
                    toolResult.raw = output;
                    toolResult.toolOutput.result = stringifyJSONToMessageContent(output);
                    toolResult.returnDirect = toolCall.toolName === "handOff";
                } catch (error) {
                    toolResult.toolOutput.isError = true;
                    toolResult.toolOutput.result = `Error: ${error}`;
                }
                results.push(toolResult);
                // Send single tool result event, useful for UI
                sendEvent(agentToolCallResultEvent.with(toolResult));
            }
            return toolResultsEvent.with({
                agentName,
                results
            });
        };
        this.processToolResults = async (event)=>{
            const { agentName, results } = event.data;
            // Get agent
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            await agent.handleToolCallResults(this.stateful.getContext().state, results);
            const directResult = results.find((r)=>r.returnDirect);
            if (directResult) {
                const isHandoff = directResult.toolName === "handOff";
                const output = typeof directResult.toolOutput.result === "string" ? directResult.toolOutput.result : JSON.stringify(directResult.toolOutput.result);
                const agentOutput = {
                    response: {
                        role: "assistant",
                        content: output
                    },
                    toolCalls: [],
                    raw: output,
                    currentAgentName: agent.name
                };
                await agent.finalize(this.stateful.getContext().state, agentOutput);
                if (isHandoff) {
                    const nextAgentName = this.stateful.getContext().state.nextAgentName;
                    console.log(`[Agent ${agentName}]: Handoff to ${nextAgentName}: ${directResult.toolOutput.result}`);
                    if (nextAgentName) {
                        this.stateful.getContext().state.currentAgentName = nextAgentName;
                        this.stateful.getContext().state.nextAgentName = null;
                        const messages = await this.stateful.getContext().state.memory.getMessages();
                        return agentInputEvent.with({
                            input: messages,
                            currentAgentName: nextAgentName
                        });
                    }
                }
                return stopAgentEvent.with({
                    result: output,
                    state: this.stateful.getContext().state
                });
            }
            // Continue with another agent step
            const messages = await this.stateful.getContext().state.memory.getMessages();
            return agentInputEvent.with({
                input: messages,
                currentAgentName: agent.name
            });
        };
        this.verbose = verbose ?? false;
        // Handle AgentWorkflow cases for agents
        const processedAgents = [];
        if (agents.length > 0) {
            if (agents[0] instanceof AgentWorkflow) {
                // If agents is AgentWorkflow[], extract the BaseWorkflowAgent from each workflow
                const agentWorkflows = agents;
                agentWorkflows.forEach((workflow)=>{
                    const workflowAgents = workflow.getAgents();
                    processedAgents.push(...workflowAgents);
                });
            } else {
                // Otherwise, agents is already BaseWorkflowAgent[]
                processedAgents.push(...agents);
            }
        }
        // Handle AgentWorkflow case for rootAgent and set rootAgentName
        if (rootAgent instanceof AgentWorkflow) {
            // If rootAgent is an AgentWorkflow, check if it has exactly one agent
            const rootAgents = rootAgent.getAgents();
            if (rootAgents.length !== 1) {
                throw new Error(`Root agent must be a single agent, but it is a workflow with ${rootAgents.length} agents`);
            }
            // We know rootAgents[0] exists because we checked length === 1 above
            this.rootAgentName = rootAgents[0].name;
        } else {
            // Otherwise, rootAgent is already a BaseWorkflowAgent
            this.rootAgentName = rootAgent.name;
        }
        // Validate root agent
        if (!processedAgents.some((a)=>a.name === this.rootAgentName)) {
            throw new Error(`Root agent ${this.rootAgentName} not found in agents`);
        }
        this.addAgents(processedAgents);
        this.setupWorkflowSteps();
    }
    handle(accept, handler) {
        this.workflow.handle(accept, handler);
    }
    createContext() {
        return this.workflow.createContext(this.createInitialState());
    }
    addAgents(agents) {
        const agentNames = new Set(agents.map((a)=>a.name));
        if (agentNames.size !== agents.length) {
            throw new Error("The agent names must be unique!");
        }
        agents.forEach((agent)=>{
            this.agents.set(agent.name, agent);
        });
        if (agents.length > 1) {
            agents.forEach((agent)=>{
                this.validateAgent(agent);
                this.addHandoffTool(agent);
            });
        }
    }
    validateAgent(agent) {
        // Validate that all canHandoffTo agents exist
        const invalidAgents = agent.canHandoffTo.filter((name)=>!this.agents.has(name));
        if (invalidAgents.length > 0) {
            throw new Error(`Agent "${agent.name}" references non-existent agents in canHandoffTo: ${invalidAgents.join(", ")}`);
        }
    }
    addHandoffTool(agent) {
        if (agent.tools.some((t)=>t.metadata.name === "handOff")) {
            return;
        }
        const toHandoffAgents = new Map();
        agent.canHandoffTo.forEach((name)=>{
            toHandoffAgents.set(name, this.agents.get(name));
        });
        const handoffTool = this.createHandoffTool(toHandoffAgents);
        if (agent.canHandoffTo.length > 0 && !agent.tools.some((t)=>t.metadata.name === handoffTool.metadata.name)) {
            agent.tools.push(handoffTool);
        }
    }
    /**
   * Adds a new agent to the workflow
   */ addAgent(agent) {
        this.agents.set(agent.name, agent);
        this.validateAgent(agent);
        this.addHandoffTool(agent);
        return this;
    }
    /**
   * Gets all agents in this workflow
   * @returns Array of agents in this workflow
   */ getAgents() {
        return Array.from(this.agents.values());
    }
    /**
   * Create a simple workflow with a single agent and specified tools
   * @param params - Parameters for the single agent workflow
   * @returns A new AgentWorkflow instance
   */ static fromTools(params) {
        const agent = new FunctionAgent({
            name: params.name,
            description: params.description,
            tools: params.tools,
            llm: params.llm,
            systemPrompt: params.systemPrompt,
            canHandoffTo: params.canHandoffTo
        });
        const workflow = new AgentWorkflow({
            agents: [
                agent
            ],
            rootAgent: agent,
            verbose: params.verbose ?? false,
            timeout: params.timeout ?? 60
        });
        return workflow;
    }
    setupWorkflowSteps() {
        this.workflow.handle([
            startAgentEvent
        ], this.handleInputStep);
        this.workflow.handle([
            agentInputEvent
        ], this.setupAgent);
        this.workflow.handle([
            agentSetupEvent
        ], this.runAgentStep);
        this.workflow.handle([
            agentStepEvent
        ], this.parseAgentOutput);
        this.workflow.handle([
            toolCallsEvent
        ], this.executeToolCalls);
        this.workflow.handle([
            toolResultsEvent
        ], this.processToolResults);
    }
    callTool(toolCall) {
        const tool = this.agents.get(toolCall.agentName)?.tools.find((t)=>t.metadata.name === toolCall.toolName);
        if (!tool) {
            throw new Error(`Tool ${toolCall.toolName} not found`);
        }
        return tool.call(toolCall.toolKwargs);
    }
    createInitialState() {
        return {
            memory: new ChatMemoryBuffer({
                llm: this.agents.get(this.rootAgentName)?.llm ?? Settings.llm
            }),
            scratchpad: [],
            currentAgentName: this.rootAgentName,
            agents: Array.from(this.agents.keys()),
            nextAgentName: null
        };
    }
    runStream(userInput, params) {
        if (this.agents.size === 0) {
            throw new Error("No agents added to workflow");
        }
        const state = params?.state ?? this.createInitialState();
        const { sendEvent, stream } = this.workflow.createContext(state);
        sendEvent(startAgentEvent.with({
            userInput: userInput,
            chatHistory: params?.chatHistory
        }));
        return stream.until(stopAgentEvent);
    }
    async run(userInput, params) {
        const finalEvent = (await this.runStream(userInput, params).toArray()).at(-1);
        if (!stopAgentEvent.include(finalEvent)) {
            throw new Error(`Agent stopped with unexpected ${finalEvent?.toString() ?? "unknown"} event.`);
        }
        return finalEvent;
    }
    createHandoffTool(agents) {
        const agentInfo = Array.from(agents.values()).reduce((acc, a)=>{
            acc[a.name] = a.description;
            return acc;
        }, {});
        return tool({
            name: "handOff",
            description: DEFAULT_HANDOFF_PROMPT.format({
                agent_info: JSON.stringify(agentInfo)
            }),
            parameters: z.object({
                toAgent: z.string({
                    description: "The name of the agent to hand off to"
                }),
                reason: z.string({
                    description: "The reason for handing off to the agent"
                })
            }),
            execute: ({ toAgent, reason }, contextProvider)=>{
                if (!contextProvider) {
                    throw new Error("Handoff tool internal error: Context was not provided.");
                }
                const context = contextProvider();
                const agents = context.agents;
                if (!agents.includes(toAgent)) {
                    return `Agent ${toAgent} not found. Select a valid agent to hand off to. Valid agents: ${agents.join(", ")}`;
                }
                context.nextAgentName = toAgent;
                return DEFAULT_HANDOFF_OUTPUT_PROMPT.format({
                    to_agent: toAgent,
                    reason: reason
                });
            }
        }).bind(()=>this.stateful.getContext().state);
    }
}

export { AgentWorkflow, FunctionAgent, agent, agentInputEvent, agentOutputEvent, agentSetupEvent, agentStepEvent, agentStreamEvent, agentToolCallEvent, agentToolCallResultEvent, multiAgent, startAgentEvent, stopAgentEvent, toolCallsEvent, toolResultsEvent };
